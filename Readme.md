
# Demystifying Randomness

A Deep Dive into Random Number Generators and Their Implementations.

# Introduction

In the world of computing, randomness is more than a theoretical concept—it's a cornerstone of numerous applications that drive modern technology. From securing sensitive information to simulating complex systems, random numbers play a pivotal role in ensuring efficiency, security, and fairness.

# Background

Randomness is crucial in fields such as cryptography, where it underpins the generation of secure encryption keys and cryptographic protocols. Without high-quality randomness, data security could be compromised, making it easier for malicious actors to predict or reproduce secret keys.

In simulations and modeling, randomness enables the accurate representation of real-world phenomena. Techniques like Monte Carlo simulations use random sampling to solve mathematical problems and predict outcomes in finance, engineering, and scientific research. The accuracy of these simulations depends heavily on the quality of the random numbers used.

In gaming, randomness ensures that outcomes are unpredictable and fair, enhancing the gaming experience. Whether it’s the roll of a dice, the shuffle of a deck, or the spawn of in-game items, randomness provides the element of chance that keeps games exciting and engaging.

# Let's dive into it

## What is Randomness?

Randomness refers to the lack of pattern or predictability in events. In the context of computing and mathematics, randomness is the concept of generating sequences of numbers or symbols that cannot be reasonably predicted better than by random chance. This unpredictability is essential for a variety of applications where it is crucial to ensure fairness, security, and accurate simulation of real-world phenomena.

## Types of Randomness?

### Non-Deterministic (TRNG)

Non-deterministic randomness, often referred to as "true randomness," is derived from physical processes that are inherently unpredictable. These are generated through various physical phenomena such as:

* **Thermal Noise**: Electronic circuits generate thermal noise, which is the random fluctuation of electrical signals caused by the thermal agitation of electrons. This noise can be captured and digitized to produce random numbers.

* **Radioactive Decay**: The decay of radioactive isotopes is a random process governed by quantum mechanics. Geiger counters can detect these decay events, and the timing between decays can be used to generate random numbers.

* **Photon Emission**: The emission of photons from certain materials can also be used as a source of randomness. Devices that detect single photons can record the intervals between emissions to generate random sequences.

* **Quantum Randomness**: Quantum mechanics provides several phenomena that are inherently random. For example, measurements of quantum states, such as the polarization of photons or spin of electrons, yield results that are unpredictable.

* **Atmospheric Noise**: Variations in atmospheric conditions, such as radio noise from lightning or other natural sources, can be captured and used as a source of true randomness.

#### Challenges in Generating True Randomness

While true random number generators offer high-quality randomness, they also come with certain challenges:

* **Hardware Complexity**: They often require specialized hardware to capture and process physical phenomena.

* **Environmental Sensitivity**: The quality of randomness can be affected by environmental factors such as temperature, humidity, and electromagnetic interference.

* **Speed**: They may not generate random numbers as quickly as deterministic algorithms, making them less suitable for applications requiring high-throughput random numbers.

##### True Randomness in Personal Computers

In personal computers, true randomness can be sourced from several hardware-based mechanisms:

* **Peripheral Devices**: Some peripherals, such as network cards, sound cards, and disk drives, can capture environmental noise and other random events to generate random numbers. Additionally, using keyboard, gamepad, and mouse inputs as an additional entropy source is common.

* **Hardware Random Number Generators (HRNGs)**: Many modern hardware comes with built-in HRNGs that utilize physical phenomena to generate random numbers.

  * **CPU-Support**

    * **Intel RDRAND**: Intel processors with the Ivy Bridge architecture and later include the RDRAND instruction, which provides random numbers generated by an onboard hardware RNG. This RNG uses thermal noise as its entropy source.

      Here’s an example in C, for using the RDRAND instruction to generate a 64-Bit number:

      ```c
      #include <immintrin.h>
      #include <stdio.h>

      int main() {
        unsigned long long random_number;
        
        if (_rdrand64_step(&random_number)) {
          printf("Random 64-bit number: %016llx\n", random_number);
        } else {
          printf("Failed to generate random number\n");
        }

        return 0;
      }
      ```

    * **AMD RDSEED**: Similar to Intel's RDRAND, AMD processors also include the RDSEED instruction. The source of entropy for RDSEED in AMD processors, like Intel’s implementation, is based on a hardware noise source, typically using thermal noise within the silicon to produce true random bits. This entropy source is then conditioned to ensure high-quality randomness suitable for cryptographic applications.

      Here’s an example in Rust, utilizing the RDSEED intrinsic to generate a 64-Bit number:

      ```rust
      use std::arch::x86_64::_rdseed64_step;

      fn main() {
          let mut random_number: u64 = 0;
          let success: i32;

          unsafe {
              success = _rdseed64_step(&mut random_number);
          }

          if success == 1 {
              println!("Random 64-bit number: {:016x}", random_number);
          } else {
              println!("Failed to generate random number");
          }
      }
      ```

    * **ARM RNDR**: In ARM architecture, RNDR and RNDRRS are instructions used to read random numbers. These instructions are part of the ARMv8.5-A architecture and later versions, providing access to random number generation functionality directly from the CPU.

      Here’s an example in ARM-Assembler, using the RNDR register to generate a 64-Bit number:

      ```armasm
      .global _start

      .section .data
      random_number: .space 8

      .section .text
      _start:
          mrs x0, RNDR
          str x0, random_number
          
          mov x8, 93
          mov x0, 0
          svc 0
      ```

  * **Operating System Support**
  
    * **Windows**: Windows operating systems provide access to hardware-based randomness through the Cryptography API: Next Generation (CNG) using functions such as `BCryptGenRandom`.

      Here’s an example in C++, using the bcrypt library to generate a 64-Bit number:

      ```c++
      #include <windows.h>
      #include <bcrypt.h>
      #include <iostream>

      #pragma comment(lib, "bcrypt.lib")

      int main() {
          UCHAR random_number[8]; // Generate 64-bit random number
          NTSTATUS status = BCryptGenRandom(
              NULL,
              random_number,
              sizeof(random_number),
              BCRYPT_USE_SYSTEM_PREFERRED_RNG
          );

          if (status == STATUS_SUCCESS) {
              std::cout << "Random 64-bit number: ";
              for (int i = 0; i < sizeof(random_number); i++) {
                  printf("%02x", random_number[i]);
              }
              std::cout << std::endl;
          } else {
              std::cerr << "Failed to generate random number" << std::endl;
          }

          return 0;
      }
      ```

    * **Linux**: Linux offers support for HRNGs through the `/dev/random` and `/dev/urandom` devices, which include entropy from hardware sources. Additionally, the `getrandom()` system call can be used for this purpose. The `getrandom()` system call is recommended because it blocks until enough entropy is available, ensuring high-quality random numbers, especially useful during the early boot phase.

      Here’s an example in Perl, using these virtual files to generate a 64-Bit number:

      ```perl
      use strict;
      use warnings;

      my $random_number;
      open my $fh, '<', '/dev/urandom' or die "Can't open /dev/urandom: $!";
        binmode $fh;
        read $fh, $random_number, 8; # Read 64-bit random number
      close $fh;

      print "Random 64-bit number: ";
      foreach my $byte (split //, $random_number) {
        printf "%02x", ord($byte);
      }
      print "\n";
      ```

    * **macOS**: macOS provides access to high-quality random numbers through the `SecRandomCopyBytes` function in the Security framework.

      Here’s an example in Python, using the OS-function to generate a 64-Bit number:

      ```python
      import ctypes
      import os

      def get_random_bytes(n):
        buf = (ctypes.c_ubyte * n)()
        result = ctypes.cdll.LoadLibrary(ctypes.util.find_library("Security")).SecRandomCopyBytes(None, n, buf)
        if result != 0:
          raise ValueError("Failed to generate random bytes")
        return bytes(buf)

      random_bytes = get_random_bytes(8)  # Generate 64-bit random number
      print("Random 64-bit number: ", random_bytes.hex())
      ```

### Deterministic

Deterministic randomness is generated by algorithms designed to produce sequences of numbers that appear random but are actually determined by some initial value. Unlike true random numbers, these sequences are predictable if the state and algorithm are known. Despite this predictability, high-quality deterministic random number generators can produce sequences that are sufficiently random for many practical applications. All of them use an internal state and perform various computational operations to generate each number in the sequence, updating the internal state with each invocation to ensure the sequence continues.

### Seeds - Source of Entropy

Seeds play a crucial role in generating deterministic random numbers. A seed is an initial value provided to a generator that determines the sequence of numbers it produces. The same seed will always result in the same sequence, which is essential for reproducibility in many applications. In most cases the seed will not be the first value produced, but a starting point for the internal state machine.

#### Importance of Seeds

* **Reproducibility**: In simulations and testing, reproducibility is vital. Using the same seed allows researchers and developers to regenerate the same sequence of random numbers, ensuring consistent results and enabling the verification of experiments or debugging of programs.

* **Initialization**: Seeds are used to initialize the internal state of the generator. The quality of the seed impacts the quality of the random numbers generated. Poorly chosen seeds can lead to predictable sequences, undermining the randomness.

* **Entropy Sources**: For cryptographic applications, seeds must be derived from high-entropy sources to ensure unpredictability. Entropy sources can include any non-deterministic source, or system states that are difficult to predict.

#### Generating Seeds

* **Time-based Seeds**: A common method is using the current time as a seed, leveraging the system clock. However, this can be predictable if the exact time the seed was generated is known.

  Here’s an example in VB.NET, using the current time to seed a random number generator:

  ```vbnet
  Imports System

  Module Program
      Sub Main()
          Dim seed As Integer = DateTime.Now.Ticks And Integer.MaxValue
          Dim rand As New Random(seed)
          Console.WriteLine("Random 64-bit number: " & rand.NextInt64())
      End Sub
  End Module
  ```

* **Hardware Entropy**: Using hardware-based random number generators (HRNGs) to obtain entropy, which is then used as a seed.

* **Re-Seeding**: It is also very common to update the seed after a given amount of generated numbers or based on a timer, to make the outcomes even more unpredictable.

  Here’s an example in Pascal, showing re-seeding after the first number was generated:

  ```pascal
  program GenerateRandom64Bit;

  uses
    SysUtils;

  function Generate64BitRandomNumber: UInt64;
  begin
    Result := (UInt64(Random(MaxInt)) shl 32) or UInt64(Random(MaxInt));
  end;

  var
    RandomNumber: UInt64;
  begin
    // Seed the random number generator with the current time
    Randomize;
    RandomNumber := Generate64BitRandomNumber;
    WriteLn('First 64-bit random number: ', RandomNumber);

    // Re-Seed the random number generator again with the current time
    Randomize;
    RandomNumber := Generate64BitRandomNumber;
    WriteLn('Second 64-bit random number: ', RandomNumber2);

    ReadLn;
  end.
  ```

Using a high-entropy seed source, especially in cryptographic applications, ensures that the generator produces a sequence that is difficult to predict and reverse-engineer.

## Types of Random Number Generators (RNG)

### Pseudo-Random Number Generators (PRNG)

#### PRNG Characteristics

* **Deterministic**: PRNGs generate sequences of numbers that are determined by an initial seed. The same seed will always produce the same sequence.

* **Fast**: PRNGs are typically faster than true random number generators because they use algorithmic processes rather than physical phenomena.

* **Reproducible**: Essential for applications where reproducibility is necessary, such as simulations and debugging.

#### PRNG Applications

* **Simulations and Modeling**: PRNGs are widely used in simulations, such as Monte Carlo simulations, where large quantities of random numbers are needed.

* **Games**: PRNGs provide the randomness required for game mechanics, ensuring fair play and varied experiences.

* **Procedural Generation**: Used in applications like procedural content generation in games and art, where large, diverse datasets are created algorithmically.

### Cryptographically Secure Random Number Generators (CSRNG)

#### CSRNG Characteristics

* **Unpredictable**: CSRNGs are designed to be cryptographically secure, meaning their outputs are unpredictable and resistant to reverse-engineering.

* **High Entropy**: They use high-entropy sources for seeding to ensure the randomness quality.

* **Security**: They incorporate mechanisms to prevent attackers from predicting future outputs even if some internal states are known.

#### CSRNG Applications

* **Cryptography**: Generating keys, salts, nonces, initialization vectors, and other cryptographic values that require high security.

* **Secure Protocols**: Ensuring the unpredictability of random values in secure communication protocols.

#### CSRNG Construction

Although it is possible to use a stream cipher, a block cipher or a cryptographically secure hash function to create a generator, these constructions often do not have the desired statistical properties and therefore need to be further tweaked to be practically useful.

### Cascade Construction RNG

Most hardware RNG, especially those found in CPUs utilize a cascade of on-chip thermal entropy and a CSRNG (for example Intel is utilizing the AES-block cipher in counter mode and CBC-MAC), re-seeded again and again to present you a HRNG. This leads to high-throughput hard-to-predict random numbers.

## Benchmarking RNGs

Benchmarking random number generators involves evaluating their performance and quality to determine their suitability for various applications. This process covers several key aspects, which we will now dive into.

### Categories

#### Speed

Speed is a crucial metric for RNGs, especially in applications requiring a high throughput of random numbers, such as simulations and gaming. The generation rate is typically measured in terms of the number of random numbers generated per second or the average time taken to generate a single random number.

##### Methods for determining generation speed

* **Microbenchmarking:** Using precise timers to measure the time taken to generate a large sequence of random numbers.

* **Profiling Tools:** Using performance profiling tools (e.g., `perf` on Linux, `gprof` on Unix) to analyze and record the time taken by RNG functions.

#### Memory

Memory usage is another critical factor, especially for applications with limited resources. Benchmarking memory usage involves evaluating the amount of memory required by the RNG to maintain its state and generate random numbers.

##### Methods for resource usage analysis

* **Static Analysis:** Evaluating the memory requirements of the RNG's data structures and state variables.

* **Dynamic Analysis:** Monitoring the actual memory usage during the execution of the RNG using profiling tools.

#### Uniform Distribution

Uniform distribution is a fundamental property of high-quality RNGs, ensuring that each possible outcome is equally likely. Benchmarks for uniform distribution assess whether the numbers generated by the RNG follow a uniform distribution.

##### Methods for ensuring equal probability for all outcomes

* **Histogram Analysis:** Collecting a large number of random samples and plotting a histogram to visually inspect the distribution.

* **Chi-Square Test:** Performing a statistical chi-square test to determine if the observed distribution matches the expected uniform distribution.

#### Independence / Correlation

High-quality RNGs produce sequences where each number is independent of the others, meaning there should be no discernible patterns or correlations. Benchmarks for independence and correlation assess whether the generated numbers are truly independent.

##### Methods for ensuring lack of patterns or dependencies in sequences

* **Autocorrelation Test:** Measuring the correlation between numbers in the sequence separated by various lag distances.

* **Runs Test:** Evaluating the randomness of a sequence by analyzing the occurrence and length of runs (consecutive sequences of increasing or decreasing numbers).

#### Period Length

The period length of an RNG is the number of values it produces before the sequence starts repeating. A long period is essential for applications requiring large amounts of random data to ensure the sequence does not repeat prematurely.

##### Methods for assuring long periods in RNGs

* **Theoretical Calculation:** Analyzing the algorithm to determine its maximum period length based on its mathematical properties.

* **Empirical Testing:** Generating random numbers and detecting repetitions to estimate the actual period length.

### Test-Suites

#### Diehard [1](https://github.com/eltonlaw/diehard)

These tests are a suite of statistical tests designed by George Marsaglia to assess the quality of RNGs. These tests evaluate various aspects of randomness, including distribution uniformity, independence, and the occurrence of patterns.

##### Key Tests of Diehard

* **Birthday Spacings:** Tests for the spacing between repeated values.

* **Overlapping Permutations:** Checks for the frequency of overlapping permutations in sequences.

* **Rank of Matrices:** Evaluates the rank of matrices constructed from random numbers.

#### TestU01 [1](https://simul.iro.umontreal.ca/testu01/tu01.html)

This is a comprehensive software library developed by Pierre L'Ecuyer for testing RNGs. It includes several batteries of tests, ranging from small (Crush) to large (BigCrush), providing a thorough evaluation of an RNG's statistical properties.

##### Key Features of TestU01

* **SmallCrush:** A smaller battery for quick assessments
* **Crush:** A moderate battery of tests suitable for initial evaluations.
* **BigCrush:** A large and highly stringent battery for thorough testing.

#### NIST Statistical Test Suite [1](https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf)

The NIST Statistical Test Suite is a set of tests developed by the National Institute of Standards and Technology to evaluate the quality of random numbers, particularly for cryptographic applications. This suite assesses the randomness of binary sequences.

##### Key Features of NIST

* **Frequency (Monobit) Test:** Evaluates the proportion of ones and zeros.

* **Runs Test:** Analyzes the occurrence and length of runs in the sequence.

* **Approximate Entropy Test:** Measures the entropy, or unpredictability, of the sequence.

## Algorithms

The upcoming algorithms may contain sample implementation in C#. For all of them we are gonna use a common interface to generate 64-Bit random numbers:

```c#
public interface IRandomNumberGenerator {
  void Seed(ulong seed);
  ulong Next();
}
```

### Middle Square (MS) [1](http://bit-player.org/2022/the-middle-of-the-square)

This method was proposed by John von Neumann in 1946. It generates a sequence of n-digit pseudorandom numbers by squaring an n-digit starting value and extracting the middle n digits from the result. This process is repeated to generate additional numbers. The value of n must be even to ensure a well-defined middle portion of the digits. The maximum period length for an n-digit generator is 8n.

Although it is historically significant, it is not widely used today due to its poor randomness quality. The middle-square method is often ineffective for practical applications because it typically has a very short period and significant shortcomings. With enough repetitions, it will start to generate the same number repeatedly (for example 0 or 1) or revert to a previous number in the sequence, causing an endless loop.

The code example will work on binary instead of decimal digits.

```cs
public class MiddleSquare : IRandomNumberGenerator {

  private ulong _state;

  public void Seed(ulong seed) => this._state = seed;

  public ulong Next() {
    var high = Next32();
    var low = Next32();
    return (ulong)high << 32 | low;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    uint Next32() {
      this._state *= this._state;
      return (uint)(this._state >> 16);
    }
  }

}
```

### Middle Square Weyl Sequence (MSWS) [1](https://arxiv.org/pdf/1704.00358)

This method was proposed by Bernard Widynski in 2017. This algorithm improves upon the classic Middle Square method by incorporating a Weyl sequence, which helps to avoid the short periods and cycles that the original Middle Square method suffers from. MSWS combines the squaring process of the Middle Square method with an additional Weyl sequence to improve randomness quality and performance.

The Weyl sequence is an integer stepping sequence of period \(2^{64}\), which is used to add an additional element of randomness to each iteration. This sequence ensures that the generator does not fall into short cycles or the "zero mechanism" problem where the generator would continue to produce zero outputs.

```cs
public class MiddleSquareWeylSequence : IRandomNumberGenerator {

  private const ulong _WEYL_CONSTANT = 0xB5AD4ECEDA1CE2A9;
  private ulong _state;
  private ulong _weyl;
  
  public void Seed(ulong seed) => this._state = this._weyl = seed;
  
  public ulong Next() {
    this._state *= this._state;
    this._state += this._weyl += _WEYL_CONSTANT;
    var register = this._state;
    var high = (register >> 32);
    var low = register << 32;
    return this._state = low | high;
  }

}
```

### XorShift (XS) [1](https://www.jstatsoft.org/index.php/jss/article/view/v008i14/916)

This method was introduced by George Marsaglia in 2003, and is a class of extremely fast and simple RNGs. These generators operate by repeatedly applying the exclusive-or (xor) operation combined with bit shifts to produce sequences of random numbers. XorShift RNGs can generate sequences of integers with periods \(2^k - 1\) for values of \(k\) like 32, 64, 96, 128, 160, and 192.

The algorithm uses a binary vector space model where each step involves applying a linear transformation over the binary vectors. The primary operations involve xor'ing a computer word with a shifted version of itself, either left or right. For instance, the operations

\(y \oplus ( y << a )\) shifts \(y\) left by \(a\) bits and xor's the result with \(y\) whereas
\(y \oplus ( y >> a )\) shifts \(y\) right by \(a\) bits and xor's the result with \(y\).

```cs
public class XorShift : IRandomNumberGenerator {
  
  private ulong _state;

  public void Seed(ulong seed) => this._state = seed == 0 ? 1 : seed;

  public ulong Next() {
    var s = this._state;
    s ^= s << 7;
    s ^= s >> 9;
    return this._state = s;
  }

}
```

### XorShift+ (XS+) [1](https://arxiv.org/pdf/1404.0390)

This method, introduced by Sebastiano Vigna, is an extension of XS generators. Instead of using a multiplication operation, XS+ returns the sum of two consecutive outputs from the XS generator. This approach helps to eliminate linear artifacts typically associated with linear operations in
\(\mathbb{Z}/2^{32}\mathbb{Z}\). The XS+ generators have been adopted in various JavaScript engines, including those in Chrome, Firefox, Safari, and Microsoft Edge. They are faster and have better statistical properties than some earlier RNGs, passing rigorous tests like BigCrush from the TestU01 suite.

It is also designed to avoid weaknesses in lower bits that were observed in some other RNGs, ensuring a uniform distribution of random numbers.

```cs
public class XorShiftPlus : IRandomNumberGenerator {

  private ulong _x, _y;

  public void Seed(ulong seed) {
    this._x = seed == 0 ? 1 : seed;
    this._y = ~seed == 0 ? 1 : ~seed;
  }

  public ulong Next() {
    var x = this._x;
    var y = this._y;

    x ^= x << 23;
    x ^= x >> 17;
    x ^= y ^ (y >> 26);

    return (this._x = y) + (this._y = x);
  }

}
```

### XorShift* (XS*) [1](https://rosettacode.org/wiki/Pseudo-random_numbers/Xorshift_star)

These generators are an enhancement over the basic XS generators, incorporating an invertible multiplication (modulo the word size) as a non-linear transformation to the output. This technique was suggested by Marsaglia to address linear artifacts inherent in pure XS generators. The multiplication step ensures that the output sequence is equidistributed in the maximum possible dimension, which means it spans all possible values in its range more uniformly than the basic XS. These generators are designed to produce high-quality pseudorandom numbers and are widely used due to their simplicity and efficiency.

```cs
public class XorShiftStar : IRandomNumberGenerator {
  
  private const ulong _MULTIPLICATOR = 0x2545F4914F6CDD1D;
  private ulong _state;

  public void Seed(ulong seed) => this._state = seed == 0 ? 1 : seed;

  public ulong Next() {
    var s = this._state;
    s ^= s >> 12;
    s ^= s << 25;
    s ^= s >> 27;

    return (this._state = s) * _MULTIPLICATOR;
  }

}
```

### XorWow

This is another variant introduced by Marsaglia, that adds a simple additive counter (a Weyl sequence) to the output of a XorShift generator. This method extends the period and enhances the randomness of the output. The XorWow generator is used as the default RNG in Nvidia's CUDA toolkit, demonstrating its effectiveness in high-performance computing environments.

```cs
public class XorWow : IRandomNumberGenerator {
  
  private const uint _WEYL_CONSTANT = 362437;
  private uint _x, _y, _z, _w, _v, _weyl;
  
  public void Seed(ulong seed) {
    var low = (uint)seed;
    var high = (uint)(seed >> 32);

    var s0 = low ^ 0xAAD26B49;
    var s1 = high ^ 0xF7DCEFDD;
    var t0 = 1099087573 * s0;
    var t1 = 2591861531 * s1;

    this._weyl = 6615241 + t1 + t0;
    this._x = 123456789 + t0;
    this._y = 362436069 ^ t0;
    this._z = 521288629 + t1;
    this._w = 88675123 ^ t1;
    this._v = 5783321 + t0;
  }

  public ulong Next() {
    var high = Next32();
    var low = Next32();
    return (ulong)high << 32 | low;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    uint Next32() {
      var x = this._x;
      x ^= x >> 2;
      x ^= x << 1;

      (this._x, this._y, this._z, this._w) = (this._y, this._z, this._w, this._v);

      var v = this._v;
      v ^= v << 4;
      v ^= x;

      return (this._v = v) + (this._weyl += _WEYL_CONSTANT);
    }
  }

}
```

### SplitMix (SM) [1](https://gee.cs.oswego.edu/dl/papers/oopsla14.pdf)

This generator is a simple and fast pseudo-random number generator designed by Sebastiano Vigna. It combines adding the golden gamma constant (\(2^{64}/\phi\) where \(\phi = \frac{1 + \sqrt{5}}{2}\)) to David Stafford’s Mix13 variant of the MurmurHash3 finalizer. It's primarily used for initializing the states of other more complex generators, such as Xoroshiro and Xoshiro. It is particularly well-suited for this purpose because of its excellent statistical properties and simplicity.

```cs
public class SplitMix64 : IRandomNumberGenerator {
  
  private const ulong _GOLDEN_GAMMA = 0x9E3779B97F4A7C15;
  private ulong _state;

  public void Seed(ulong seed) => this._state = seed;

  public ulong Next() {
    var z = (this._state += _GOLDEN_GAMMA);
    z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9;
    z = (z ^ (z >> 27)) * 0x94D049BB133111EB;
    z ^= (z >> 31);
    return this._state = z;
  }

}
```

### XoShiRo (XSR) [1](https://prng.di.unimi.it/)

This algorithm is designed for high performance and quality. It uses a combination of XOR operations, bitwise shifts, and bitwise rotations to generate random numbers. XSR256** is used in various software implementations, including the GNU Fortran compiler, Lua 5.4, and the .NET framework from version 6.0 onwards.

```cs
public class Xoshiro256SS : IRandomNumberGenerator {
  private ulong _w, _x, _y, _z;

  public void Seed(ulong seed) {
    this._w = SplitMix64(ref seed);
    this._x = SplitMix64(ref seed);
    this._y = SplitMix64(ref seed);
    this._z = SplitMix64(ref seed);

    return;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static ulong SplitMix64(ref ulong z) {
      z += 0x9E3779B97F4A7C15;
      z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9;
      z = (z ^ (z >> 27)) * 0x94D049BB133111EB;
      return z ^= (z >> 31);
    }
  }
  
  public ulong Next() {
    var result = RotateLeft(this._x * 5, 7) * 9;

    var x = this._x << 17;

    this._y ^= this._w;
    this._z ^= this._x;
    this._x ^= this._y;
    this._w ^= this._z;

    this._y ^= x;
    this._z = RotateLeft(this._z, 45);

    return result;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static ulong RotateLeft(ulong x, int k) => (x << k) | (x >> (64 - k));
  }

}
```

### XoRoShiRo (XRSR) [1](https://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf)

The name stands for XOR/rotate/shift/rotate, which describes the core operations used in these generators. These generators are designed to provide high performance utilizing less memory while maintaining excellent statistical properties

```cs
public class Xoroshiro128PlusPlus : IRandomNumberGenerator {
  private ulong _x;
  private ulong _y;

  public void Seed(ulong seed) {
    this._x = SplitMix64(ref seed);
    this._y = SplitMix64(ref seed);

    return;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static ulong SplitMix64(ref ulong z) {
      z += 0x9E3779B97F4A7C15;
      z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9;
      z = (z ^ (z >> 27)) * 0x94D049BB133111EB;
      return z ^= (z >> 31);
    }
  }

  public ulong Next() {
    var x = this._x;
    var y = this._y;
    var result = RotateLeft(x + y, 17) + x;

    y ^= x;
    this._x = RotateLeft(x, 49) ^ y ^ (y << 21);
    this._y = RotateLeft(y, 28);

    return result;

    static ulong RotateLeft(ulong x, int k) => (x << k) | (x >> (64 - k));
  }
  
}
```

### Multiplicative Linear Congruential Generator (MLCG) [1](https://en.wikipedia.org/wiki/Lehmer_random_number_generator)

Originally introduced by D.H. Lehmer in 1951, the Multiplicative Linear Congruential Generator (MLCG) is a simple and efficient method for generating pseudo-random numbers. It uses the following formula:

\[X_{n+1} = (a \cdot X_n) \mod m\]

* \(X\) is the sequence of pseudo-random values.
* \(m\) is the modulus, \(0 < m\).
* \(a\) is the multiplier, \(0 < a < m\).
* \(X_0\) is the seed or start value, \(0 \leq X_0 < m\).

In 1988, Stephen K. Park and Keith W. Miller proposed a widely adopted variant of the MLCG with specific parameters: \(a = 16807\) and \(m=2^{31}-1\) (which is a prime number known as the Mersenne prime). This choice of parameters ensures a long period of \(2^{31}-2\), good statistical properties, and efficient computation.

```cs
public class MultiplicativeLinearCongruentialGenerator : IRandomNumberGenerator {
  
  private const ulong _MULTIPLIER = 6364136223846793005;
  private ulong _state;

  public void Seed(ulong seed) => this._state = seed == 0 ? 1 : seed;

  public ulong Next() => _state *= _MULTIPLIER; // implicit mod 2^64

}
```

### Linear Congruential Generator (LCG) [1](https://en.wikipedia.org/wiki/Linear_congruential_generator)

This is one of the oldest and most well-known PRNG algorithms. Introduced by W. E. Thomson and A. Rotenberg in 1958, it generates a sequence of numbers using a piecewise linear equation. The generator is defined by the recurrence relation:

\[X_{n+1} = (a \cdot X_n + c) \mod m\]

Where:

* \(X\) is the sequence of pseudo-random values.
* \(m\) is the modulus, \(0 < m\).
* \(a\) is the multiplier, \(0 < a < m\).
* \(c\) is the increment, \(0 \leq c < m\).
* \(X_0\) is the seed or start value, \(0 \leq X_0 < m\).

The Linear Congruential Generator is a simple and efficient way to produce pseudo-random numbers. However, the quality of the output is highly dependent on the choice of parameters $a$, $c$, and $m$. Properly chosen parameters ensure a long period and good statistical properties, making the LCG suitable for many applications, although it is generally not recommended for cryptographic purposes due to its predictability.

```cs
public class LinearCongruentialGenerator : IRandomNumberGenerator {

  private const ulong _MULTIPLIER = 6364136223846793005;
  private const ulong _INCREMENT = 1442695040888963407;
  private ulong _state;

  public void Seed(ulong seed) => this._state = seed;

  public ulong Next() => this._state = (_MULTIPLIER * _state + _INCREMENT); // implicit mod 2^64

}
```

### Combined Linear Congruential Generator (CLCG) [1](https://en.wikipedia.org/wiki/Combined_linear_congruential_generator)

This is an extension of the LCG designed to improve the statistical properties and period length by combining multiple LCGs. This method aims to mitigate the weaknesses inherent in single LCGs, such as short periods and poor distribution, by combining several generators with different parameters.

In a CLCG, multiple LCGs are run in parallel, and their outputs are combined using addition or XOR operations to produce the final random number. The combination of multiple generators with carefully chosen parameters ensures that the resulting sequence has a much longer period and better statistical properties than any individual LCG.

Each \(X_{n,i}\) is generated by an individual LCG with its own set of parameters:

\[X_{n+1,i} = (a_i \cdot X_{n,i} + c_i) \mod m_i\]

The CLCG can be defined using one of the following formulas, where \(k\) LCGs are combined:

\[X_{n+1} = \left [ \sum_{i=1}^k {(a_i \cdot X_{n,i} + c_i) \mod m_i} \right ] \mod m = \left [ \sum_{i=1}^k {X_{n+1,i}} \right ] \mod m = [X_{n+1,1}+\cdots+X_{n+1,k}] \mod m\]
\[X_{n+1} = \left [ \prod_{i=1}^k {(a_i \cdot X_{n,i} + c_i) \mod m_i} \right ] \mod m = \left [ \prod_{i=1}^k {X_{n+1,i}} \right ] \mod m = [X_{n+1,1} \cdot \cdots \cdot X_{n+1,k}] \mod m\]

Where:

* \(X\) is the sequence of pseudo-random values.
* \(X_{n,i}\) is the sequence of pseudo-random values from the \(i\)-th LCG.
* \(m\) is the modulus of the CLCG.
* \(m_i\) is the modulus of the \(i\)-th LCG.
* \(a_i\) is the multiplier of the \(i\)-th LCG.
* \(c_i\) is the increment of the \(i\)-th LCG.
* \(X_{0,i}\) is the seed of the \(i\)-th LCG.

```cs
public class CombinedLinearCongruentialGenerator : IRandomNumberGenerator {

  private ulong _state1;
  private ulong _state2;

  private const ulong _a1 = 6364136223846793005;  // Multiplier for LCG1
  private const ulong _c1 = 1442695040888963407;  // Increment  for LCG1
  
  private const ulong _a2 = 3935559000370003845;  // Multiplier for LCG2
  private const ulong _c2 = 2691343689449507681;  // Increment  for LCG2
  
  public void Seed(ulong seed) {
    this._state1 = seed;
    this._state2 = seed ^ 0x5DEECE66D; // Ensure different seeds for the two LCGs
  }

  public ulong Next() // implicit mod 2^64
    => (this._state1 = (_a1 * this._state1 + _c1)) 
     + (this._state2 = (_a2 * this._state2 + _c2))
     ;
    
}
```

### Inversive Congruential Generator (ICG) [1](https://www.ams.org/journals/mcom/1991-56-193/S0025-5718-1991-1052092-X/S0025-5718-1991-1052092-X.pdf)

These are a type of nonlinear congruential pseudorandom number generator that use the modular multiplicative inverse to generate the next number in a sequence. These generators offer excellent uniformity properties and longer periods compared to LCGs.

The standard formula for an ICG, modulo a prime number \(q\), is:

\[
X_{i+1} =
\begin{cases}
(a \cdot X_i^{-1} + c) \mod q & \text{if } X_i \neq 0 \\
c & \text{if } X_i = 0
\end{cases}
\]

Where:

* \(X_i\) is the current value in the sequence.
* \(a\) is the multiplier.
* \(c\) is the increment.
* \(q\) is the modulus.
* \(X_i^{-1}\) is the modular multiplicative inverse of \(X_i\) modulo \(q\).

The maximum period for an ICG is \(q\), provided \(a\) and \(c\) are chosen appropriately, such that the polynomial \(f(x) = x^2 - cx - a\) is primitive over the finite field \(\mathbb{F}_q\).

```cs
public class InversiveCongruentialGenerator : IRandomNumberGenerator {

  private ulong _state;
  private const ulong _a = 6364136223846793005;
  private const ulong _c = 1442695040888963407;
  private const ulong _q = 18446744073709551557;

  public void Seed(ulong seed) => this._state = seed % _q;

  public ulong Next() {
    if (_state == 0) {
      _state = _c;
    } else {
      _state = (_a * ModInverse(_state, _q) + _c) % _q;
    }
    return _state;
  }

  private ulong ModInverse(ulong value, ulong modulus) {
    ulong t = 0, newT = 1;
    ulong r = modulus, newR = value;
    
    while (newR != 0) {
      ulong quotient = r / newR;
      (t, newT) = (newT, t - quotient * newT);
      (r, newR) = (newR, r - quotient * newR);
    }

    if (r > 1) throw new ArithmeticException("Value has no modular inverse.");
    if (t < 0) t += modulus;

    return t;
  }
}
```

### MIXMAX [1](https://arxiv.org/pdf/1403.5355)

This generator is based on the properties of Kolmogorov-Anosov C-systems, which are a class of chaotic dynamical systems known for their excellent mixing properties. This generator utilizes an integer-valued unimodular matrix of size NxN and arithmetic defined on a Galois field GF[p] with a large prime modulus p. The primary idea is to leverage the dynamics of linear automorphisms on the unit hypercube in \(\mathbb{R}^N\), which can be expressed as:

\[u_i(t + 1) = \sum_{j=1}^{N} A_{ij} u_j(t) \mod 1\]

Here, \(u\) represents the vector in the unit interval [0, 1), and \(A\) is the defining matrix whose entries are integers, \(A_{ij} \in \mathbb{Z}\). The conditions for the matrix \(A\) to ensure the desired properties are:

* \(\det A = 1\)
* The eigenvalues \(\lambda_k\) of \(A\) must not lie on the unit circle, i.e., \(|\lambda_k| \neq 1\) for all \(k = 1, 2, ..., N\).

These conditions ensure that the map defined by \(A\) is volume-preserving and exhibits exponential divergence of nearby trajectories, creating a highly chaotic and mixing behavior necessary for generating high-quality pseudo-random numbers.

The specific form of the MIXMAX matrix used in the generator is:

\[ A =
\begin{pmatrix}
1 & 1 & 1 & 1 & \cdots & 1 \\
1 & 2 & 1 & 1 & \cdots & 1 \\
1 & 3 + s & 2 & 1 & \cdots & 1 \\
1 & 4 & 3 & 2 & \cdots & 1 \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
1 & N & N-1 & N-2 & \cdots & 2 \\
\end{pmatrix}
\]

The matrix is recursively defined, and the only variable entry is \( A_{32} = 3 + s \), where \( s \) is a small integer chosen to avoid eigenvalues lying on the unit circle.

In practice, the MIXMAX RNG is implemented using modular arithmetic with a large prime modulus \( p \), ensuring that the state vectors remain within a finite field \( GF[p] \). The period of the generator is determined by the characteristic polynomial of the matrix \( A \), and the maximal period is attained when this polynomial is primitive in the extended Galois field \( GF[p^N] \).

```cs
public class Mixmax : IRandomNumberGenerator {
  
  private const int _matrixSize = 256;
  private const long _magicNumber = -3;
  private ulong[] _state;
  private readonly ulong[,] _matrix;

  public Mixmax() {
    this._state = new ulong[Mixmax._matrixSize];
    this._matrix = new ulong[Mixmax._matrixSize, Mixmax._matrixSize];
    this.InitializeMatrix();
  }

  private void InitializeMatrix() {
    for (var row = 0; row < Mixmax._matrixSize; ++row) {
      this._matrix[row, 0] = 1;
      for (var column = 1; column < Mixmax._matrixSize; ++column)
        if (column > row)
          this._matrix[row, column] = 1;
        else
          this._matrix[row, column] = (ulong)(row - column + 2);
    }

    this._matrix[2, 1]+= unchecked((ulong)Mixmax._magicNumber);
  }

  public void Seed(ulong seed) {
    for (var i = 0; i < Mixmax._matrixSize; ++i)
      this._state[i] = SplitMix64(ref seed);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static ulong SplitMix64(ref ulong z) {
      z += 0x9E3779B97F4A7C15;
      z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9;
      z = (z ^ (z >> 27)) * 0x94D049BB133111EB;
      return z ^= (z >> 31);
    }
  }

  public ulong Next() { // implicit mod 2^64

    ulong result = 0;
    for (var i = 0; i < Mixmax._matrixSize; ++i)
      result += this._state[i];

    var newState = new ulong[Mixmax._matrixSize];
    for (var i = 0; i < Mixmax._matrixSize; ++i) {
      newState[i] = 0;
      for (var j = 0; j < Mixmax._matrixSize; ++j)
        newState[i] += this._matrix[i, j] * this._state[j];
    }

    this._state = newState;
    return result;
  }
}
```

### Multiply with Carry (MWC) [1](http://www.cs.engr.uky.edu/~klapper/pdf/MWC.pdf)

These are a class of PRNGs that combines multiplication, addition, and a carry mechanism to produce sequences of random numbers, introduced by George Marsaglia in 1994.

The key difference between MWC and LCG is the introduction of a carry value in MWC. This carry value is carried over to the next step, which helps in achieving longer periods and better statistical properties compared to traditional LCGs.

The general formula for an MWC generator is as follows:

\[X_{n+1} = (A \cdot X_{n} + C_n) \mod m\]

Where:

* \(X_{n}\) is the current state.
* \(A\) is the multiplier.
* \(C_n\) is the carry from the previous step.
* \(m\) is the modulus.

The carry value \(C_n\) is updated in each step as follows:

\[C_{n+1} = \left\lfloor \frac{X_{n+1}}{m} \right\rfloor\]

In this mechanism, the next state \(X_{n+1}\) depends not only on the current state \(X_n\) and the multiplier \(A\), but also on the carry value \(C_n\), which introduces a non-linear component to the generator, distinguishing it from the linear nature of LCGs.

```cs
public class MultiplyWithCarry : IRandomNumberGenerator {
    private const ulong A = 6364136223846793005UL;  // Multiplier
    private ulong _state;                           // Current state
    private ulong _carry;                           // Carry value

    public void Seed(ulong seed) {
        _state = seed;
        _carry = ~seed;
    }

    public ulong Next() { // implicit mod 2^64
      UInt128 state = this._state;
      state *= A;
      state += this._carry;

      this._state = (ulong)state;
      this._carry = (ulong)(state >> 64);

      return _state;
    }
}
```

### Complementary Multiply with Carry (CMWC)

This generator is a refinement of the MWC method. In a CMWC generator, a sequence of random numbers is produced using a multiplier and a carry value, similar to the MWC method. However, the CMWC method maintains an array of states and updates them in a more sophisticated manner to improve the quality of the generated random numbers.

The CMWC generator is defined by the following parameters:

* $a$: Multiplier
* $m$: Modulus (typically a power of 2 for computational efficiency)
* $r$: The size of the state array
* $c$: Carry value
* $Q$: State array of size $r$

The generator produces the next random number using the following steps:

1. Select an index $i$ from the state array.
2. Calculate the new value of the state $Q_i$ using the formula:

   $$ t = a \cdot Q_i + c $$

3. The new state value is given by the lower bits of $t$:

   $$ Q_i = t \mod m $$

4. The carry value is updated using the upper bits of $t$:

   $$ c = \left\lfloor \frac{t}{m} \right\rfloor $$

5. The new random number is the complement of the new state value:

   $$ X_{n+1} = (m - 1) - Q_i $$

This process ensures that the state values are updated in a way that maintains a high-quality sequence of random numbers with a long period.

```cs
public class ComplementaryMultiplyWithCarry : IRandomNumberGenerator {
  private static readonly UInt128 A = 6364136223846793005UL;
  private const int R = 4096;
  private readonly ulong[] _state = new ulong[R];
  private ulong _carry;
  private int _index = R - 1;

  public void Seed(ulong seed) {
    for (var i = 0; i < R; ++i)
      this._state[i] = SplitMix64(ref seed);

    this._carry = SplitMix64(ref seed);
    return;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static ulong SplitMix64(ref ulong z) {
      z += 0x9E3779B97F4A7C15;
      z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9;
      z = (z ^ (z >> 27)) * 0x94D049BB133111EB;
      return z ^= (z >> 31);
    }

  }

  public ulong Next() { // implicit mod 2^64
    this._index = (this._index + 1) % R;
    var t = A * this._state[this._index] + this._carry;

    this._carry = (ulong)(t >> 64);
    this._state[this._index] = (ulong)t;

    return ulong.MaxValue - this._state[this._index];
  }
}
```

### Subtract with Carry (SWC)

tbd

### Feedback with Carry Shift Register (FCSR)

tbd

### Keep it simple stupid (KISS)

tbd

### Additive Congruential Random Number Generator (ACORN)

tbd

### Permutated Congruential Generator (PCG)

tbd

### Mersenne Twister (MT)

tbd

### Well Equidistributed Long-Period Linear (WELL)

tbd

### Marsaglia Polar Method (MP)

tbd

### Ziggurat (ZIG)

tbd

### Self-shrinking Generator (SSG)

tbd

### Wichmann-Hill (WH)

tbd

### Blum Blum Shub (BBS)

tbd

### ChaCha20

tbd

### Yarrow (YAR)

tbd

## Drinking Bit-Soup

### When you need less bits than the RNG provides

tbd: extraction, sponge

### When you need more bits than the RNG provides

tbd: concatenation, splitmix, spreadbits

# Points of Interest

tbd: comparison table of all in the mentioned test categories and suites
tbd: charts and visualizations
tbd: Practical examples and real-world applications.

# Links

* [RNG Engines](https://pracrand.sourceforge.net/RNG_engines.txt)


# History

* 20240711 - Initial GitHub Version
* 20240624 - Initial Version

